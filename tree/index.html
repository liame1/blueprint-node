<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - misc - octree collisions</title>
		<meta charset=utf-8 />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preload" href="/gltf/mario_kart_8_-_sunshine_airport_compressed.glb" as="fetch" type="model/gltf-binary" crossorigin="anonymous">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			Octree threejs demo - basic collisions with static triangle mesh<br />
			MOUSE to look around and to throw balls<br/>
			WASD to move and SPACE to jump
		</div>
		<div id="container"></div>
		<div id="player-count" class="player-count">Players Online: 0</div>
		<div id="loading-indicator" class="loading-indicator">Loading world...</div>
		<div id="username-overlay" class="username-overlay visible">
			<div class="username-card">
				<h2>Enter your name</h2>
				<form id="username-form" autocomplete="off">
					<input id="username-input" type="text" maxlength="20" placeholder="Your name" required />
					<button type="submit">Join</button>
					<p id="username-error" class="username-error" aria-live="polite"></p>
				</form>
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js",
					"three/addons/": "../node_modules/three/examples/jsm/"
				}
			}
		</script>

		<script src="/socket.io/socket.io.js"></script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Octree } from 'three/addons/math/Octree.js';
			import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';

			import { Capsule } from 'three/addons/math/Capsule.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

			const socket = io({ transports: ['websocket'], autoConnect: true });
			const remotePlayers = new Map();
			const PLAYER_UPDATE_INTERVAL = 100;
			let lastPlayerUpdate = 0;
			const ENABLE_STATS = window.location.search.includes('debugStats');
			const ENABLE_DEBUG_GUI = window.location.search.includes('debugGui');
			const playerCountElement = document.getElementById('player-count');
			const loadingIndicator = document.getElementById('loading-indicator');
			const usernameOverlay = document.getElementById('username-overlay');
			const usernameForm = document.getElementById('username-form');
			const usernameInput = document.getElementById('username-input');
			const usernameError = document.getElementById('username-error');
			const remoteBodyGeometry = new THREE.CylinderGeometry( 0.3, 0.3, 1.2, 12 );
			const remoteHeadGeometry = new THREE.SphereGeometry( 0.3, 16, 12 );
			const DEFAULT_PLAYER_COLOR = '#3a8ef6';
			const PROFILE_STORAGE_KEY = 'bp-player-profile';
			const PLAYER_SCALE = 0.04;
			const PLAYER_HEAD_OFFSET = 0.9;
			const PLAYER_LABEL_OFFSET = 1.4;
			const PLAYER_LABEL_SCALE_X = ( 0.32 / PLAYER_SCALE );
			const PLAYER_LABEL_SCALE_Y = ( 0.09 / PLAYER_SCALE );
			const PLAYER_CAPSULE_RADIUS = 0.35 * PLAYER_SCALE;
			const PLAYER_CAPSULE_START_Y = 0.35 * PLAYER_SCALE;
			const PLAYER_CAPSULE_END_Y = 1.0 * PLAYER_SCALE;
			const PLAYER_CENTER_TO_HEAD = PLAYER_CAPSULE_END_Y - ( ( PLAYER_CAPSULE_START_Y + PLAYER_CAPSULE_END_Y ) / 2 );
			const PLAYER_HEAD_WORLD_OFFSET = PLAYER_HEAD_OFFSET * PLAYER_SCALE;
			const PLAYER_SPAWN_OFFSET = 3;
			let playerUsername = '';
			let playerColor = DEFAULT_PLAYER_COLOR;
			let hasProfile = false;

			try {
				const stored = window.localStorage.getItem( PROFILE_STORAGE_KEY );
				if ( stored ) {
					const parsed = JSON.parse( stored );
					if ( parsed && typeof parsed.username === 'string' && parsed.username.trim() ) {
						playerUsername = parsed.username.trim();
						hasProfile = true;
					}
					if ( parsed && typeof parsed.color === 'string' && parsed.color ) {
						playerColor = parsed.color;
					}
				}
			} catch ( error ) {
				console.warn( 'Failed to load stored profile', error );
			}

			if ( hasProfile && usernameOverlay ) {
				usernameOverlay.classList.add( 'hidden' );
				usernameOverlay.style.display = 'none';
			}

			const clock = new THREE.Clock();

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x88ccee );
			scene.fog = new THREE.Fog( 0x88ccee, 0, 50 );

			const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.rotation.order = 'YXZ';

			const fillLight1 = new THREE.HemisphereLight( 0x8dc1de, 0x00668d, 1.5 );
			fillLight1.position.set( 2, 1, 1 );
			scene.add( fillLight1 );

			const directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );
			directionalLight.position.set( - 5, 25, - 1 );
			directionalLight.castShadow = true;
			directionalLight.shadow.camera.near = 0.01;
			directionalLight.shadow.camera.far = 500;
			directionalLight.shadow.camera.right = 30;
			directionalLight.shadow.camera.left = - 30;
			directionalLight.shadow.camera.top	= 30;
			directionalLight.shadow.camera.bottom = - 30;
			directionalLight.shadow.mapSize.width = 1024;
			directionalLight.shadow.mapSize.height = 1024;
			directionalLight.shadow.radius = 4;
			directionalLight.shadow.bias = - 0.00006;
			scene.add( directionalLight );

			const container = document.getElementById( 'container' );

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.VSMShadowMap;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			container.appendChild( renderer.domElement );

			if ( usernameForm ) {
				usernameForm.addEventListener( 'submit', ( event ) => {
					event.preventDefault();
					if ( ! socket.connected ) {
						if ( usernameError ) {
							usernameError.textContent = 'Connecting...';
						}
						return;
					}
					const value = ( usernameInput?.value || '' ).trim();
					if ( ! value ) {
						if ( usernameError ) {
							usernameError.textContent = 'Please enter a name.';
						}
						return;
					}
					playerUsername = value;
					hasProfile = true;
					if ( usernameError ) {
						usernameError.textContent = '';
					}
					socket.emit( 'playerProfile', { username: value } );
				} );
			}

			function showUsernameOverlay() {
				if ( ! usernameOverlay ) return;
				usernameOverlay.classList.remove( 'hidden' );
				usernameOverlay.style.display = 'flex';
				setTimeout( () => {
					if ( usernameInput && document.activeElement !== usernameInput ) {
						usernameInput.focus();
					}
				}, 50 );
			}

			function hideUsernameOverlay() {
				if ( ! usernameOverlay ) return;
				usernameOverlay.classList.add( 'hidden' );
				setTimeout( () => {
					usernameOverlay.style.display = 'none';
				}, 220 );
			}

			function persistProfile() {
				try {
					window.localStorage.setItem( PROFILE_STORAGE_KEY, JSON.stringify( {
						username: playerUsername,
						color: playerColor
					} ) );
				} catch ( error ) {
					console.warn( 'Failed to persist profile', error );
				}
			}

			function clearStoredProfile() {
				try {
					window.localStorage.removeItem( PROFILE_STORAGE_KEY );
				} catch ( error ) {
					console.warn( 'Failed to clear stored profile', error );
				}
			}

			socket.on( 'existingPlayers', ( players ) => {
				players.forEach( ( player ) => {
					if ( ! player || player.id === socket.id ) return;
					createOrUpdateRemotePlayer( player.id, player.position, player.rotation, player.username, player.color );
				} );
			} );

			socket.on( 'playerUpdated', ( player ) => {
				if ( ! player || player.id === socket.id ) return;
				createOrUpdateRemotePlayer( player.id, player.position, player.rotation, player.username, player.color );
			} );

			socket.on( 'playerDisconnected', ( { id } = {} ) => {
				if ( ! id ) return;
				removeRemotePlayer( id );
			} );

			socket.on( 'playerProfileUpdated', ( data ) => {
				if ( ! data || data.id === socket.id ) return;
				createOrUpdateRemotePlayer( data.id, data.position, data.rotation, data.username, data.color );
			} );

			socket.on( 'playerProfileAck', ( payload ) => {
				if ( ! payload ) return;
				if ( payload.error ) {
					hasProfile = false;
					playerUsername = '';
					playerColor = DEFAULT_PLAYER_COLOR;
					if ( usernameError ) {
						usernameError.textContent = payload.error;
					}
					showUsernameOverlay();
					clearStoredProfile();
					return;
				}

				playerUsername = payload.username || playerUsername;
				playerColor = payload.color || playerColor || DEFAULT_PLAYER_COLOR;
				hasProfile = true;
				persistProfile();

				if ( usernameError ) {
					usernameError.textContent = '';
				}
				hideUsernameOverlay();
				sendPlayerState( true );
			} );

			socket.on( 'activePlayerCount', ( count ) => {
				if ( playerCountElement ) {
					playerCountElement.textContent = `Players Online: ${count}`;
				}
			} );

			socket.on( 'connect', () => {
				lastPlayerUpdate = 0;
				if ( playerUsername ) {
					hasProfile = true;
					socket.emit( 'playerProfile', { username: playerUsername } );
					hideUsernameOverlay();
					sendPlayerState( true );
				} else {
					hasProfile = false;
					showUsernameOverlay();
				}
			} );

			let stats = null;
			if ( ENABLE_STATS ) {
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			}

			const GRAVITY = 30;

			const NUM_SPHERES = 100;
			const SPHERE_RADIUS = 0.2 * PLAYER_SCALE;

			const STEPS_PER_FRAME = 5;

			const sphereGeometry = new THREE.IcosahedronGeometry( SPHERE_RADIUS, 5 );
			const sphereMaterial = new THREE.MeshLambertMaterial( { color: 0xdede8d } );

			const spheres = [];
			let sphereIdx = 0;

			for ( let i = 0; i < NUM_SPHERES; i ++ ) {

				const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
				sphere.castShadow = true;
				sphere.receiveShadow = true;

				scene.add( sphere );

				spheres.push( {
					mesh: sphere,
					collider: new THREE.Sphere( new THREE.Vector3( 0, - 100, 0 ), SPHERE_RADIUS ),
					velocity: new THREE.Vector3()
				} );

			}

			const worldOctree = new Octree();

			const playerCollider = new Capsule(
				new THREE.Vector3( 0, PLAYER_CAPSULE_START_Y, 0 ),
				new THREE.Vector3( 0, PLAYER_CAPSULE_END_Y, 0 ),
				PLAYER_CAPSULE_RADIUS
			);
			playerCollider.translate( new THREE.Vector3( 0, PLAYER_SPAWN_OFFSET, 0 ) );

			const playerVelocity = new THREE.Vector3();
			const playerDirection = new THREE.Vector3();
			camera.position.set( 0, PLAYER_CAPSULE_END_Y + PLAYER_SPAWN_OFFSET, 0 );

			let playerOnFloor = false;
			let mouseTime = 0;

			const keyStates = {};

			const vector1 = new THREE.Vector3();
			const vector2 = new THREE.Vector3();
			const vector3 = new THREE.Vector3();
			const tempNetworkVector = new THREE.Vector3();

			document.addEventListener( 'keydown', ( event ) => {

				keyStates[ event.code ] = true;

			} );

			document.addEventListener( 'keyup', ( event ) => {

				keyStates[ event.code ] = false;

			} );

			container.addEventListener( 'mousedown', () => {

				document.body.requestPointerLock();

				mouseTime = performance.now();

			} );

			document.addEventListener( 'mouseup', () => {

				if ( document.pointerLockElement !== null ) throwBall();

			} );

			document.body.addEventListener( 'mousemove', ( event ) => {

				if ( document.pointerLockElement === document.body ) {

					camera.rotation.y -= event.movementX / 500;
					camera.rotation.x -= event.movementY / 500;

				}

			} );

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function throwBall() {

				const sphere = spheres[ sphereIdx ];

				camera.getWorldDirection( playerDirection );

				sphere.collider.center.copy( playerCollider.end ).addScaledVector( playerDirection, playerCollider.radius * 1.5 );

				// throw the ball with more force if we hold the button longer, and if we move forward

				const impulse = 15 + 30 * ( 1 - Math.exp( ( mouseTime - performance.now() ) * 0.001 ) );

				sphere.velocity.copy( playerDirection ).multiplyScalar( impulse );
				sphere.velocity.addScaledVector( playerVelocity, 2 );

				sphereIdx = ( sphereIdx + 1 ) % spheres.length;

			}

			function playerCollisions() {

				const result = worldOctree.capsuleIntersect( playerCollider );

				playerOnFloor = false;

				if ( result ) {

					playerOnFloor = result.normal.y > 0;

					if ( ! playerOnFloor ) {

						playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );

					}

					if ( result.depth >= 1e-10 ) {

						playerCollider.translate( result.normal.multiplyScalar( result.depth ) );

					}

				}

			}

			function updatePlayer( deltaTime ) {

				let damping = Math.exp( - 4 * deltaTime ) - 1;

				if ( ! playerOnFloor ) {

					playerVelocity.y -= GRAVITY * deltaTime;

					// small air resistance
					damping *= 0.1;

				}

				playerVelocity.addScaledVector( playerVelocity, damping );

				const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
				playerCollider.translate( deltaPosition );

				playerCollisions();

				camera.position.copy( playerCollider.end );

			}

			function playerSphereCollision( sphere ) {

				const center = vector1.addVectors( playerCollider.start, playerCollider.end ).multiplyScalar( 0.5 );

				const sphere_center = sphere.collider.center;

				const r = playerCollider.radius + sphere.collider.radius;
				const r2 = r * r;

				// approximation: player = 3 spheres

				for ( const point of [ playerCollider.start, playerCollider.end, center ] ) {

					const d2 = point.distanceToSquared( sphere_center );

					if ( d2 < r2 ) {

						const normal = vector1.subVectors( point, sphere_center ).normalize();
						const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( playerVelocity ) );
						const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( sphere.velocity ) );

						playerVelocity.add( v2 ).sub( v1 );
						sphere.velocity.add( v1 ).sub( v2 );

						const d = ( r - Math.sqrt( d2 ) ) / 2;
						sphere_center.addScaledVector( normal, - d );

					}

				}

			}

			function spheresCollisions() {

				for ( let i = 0, length = spheres.length; i < length; i ++ ) {

					const s1 = spheres[ i ];

					for ( let j = i + 1; j < length; j ++ ) {

						const s2 = spheres[ j ];

						const d2 = s1.collider.center.distanceToSquared( s2.collider.center );
						const r = s1.collider.radius + s2.collider.radius;
						const r2 = r * r;

						if ( d2 < r2 ) {

							const normal = vector1.subVectors( s1.collider.center, s2.collider.center ).normalize();
							const v1 = vector2.copy( normal ).multiplyScalar( normal.dot( s1.velocity ) );
							const v2 = vector3.copy( normal ).multiplyScalar( normal.dot( s2.velocity ) );

							s1.velocity.add( v2 ).sub( v1 );
							s2.velocity.add( v1 ).sub( v2 );

							const d = ( r - Math.sqrt( d2 ) ) / 2;

							s1.collider.center.addScaledVector( normal, d );
							s2.collider.center.addScaledVector( normal, - d );

						}

					}

				}

			}

			function updateSpheres( deltaTime ) {

				spheres.forEach( sphere => {

					sphere.collider.center.addScaledVector( sphere.velocity, deltaTime );

					const result = worldOctree.sphereIntersect( sphere.collider );

					if ( result ) {

						sphere.velocity.addScaledVector( result.normal, - result.normal.dot( sphere.velocity ) * 1.5 );
						sphere.collider.center.add( result.normal.multiplyScalar( result.depth ) );

					} else {

						sphere.velocity.y -= GRAVITY * deltaTime;

					}

					const damping = Math.exp( - 1.5 * deltaTime ) - 1;
					sphere.velocity.addScaledVector( sphere.velocity, damping );

					playerSphereCollision( sphere );

				} );

				spheresCollisions();

				for ( const sphere of spheres ) {

					sphere.mesh.position.copy( sphere.collider.center );

				}

			}

			function getForwardVector() {

				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();

				return playerDirection;

			}

			function getSideVector() {

				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( camera.up );

				return playerDirection;

			}

			function controls( deltaTime ) {

				// gives a bit of air control
				const speedDelta = deltaTime * ( playerOnFloor ? 25 : 8 );

				if ( keyStates[ 'KeyW' ] ) {

					playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );

				}

				if ( keyStates[ 'KeyS' ] ) {

					playerVelocity.add( getForwardVector().multiplyScalar( - speedDelta ) );

				}

				if ( keyStates[ 'KeyA' ] ) {

					playerVelocity.add( getSideVector().multiplyScalar( - speedDelta ) );

				}

				if ( keyStates[ 'KeyD' ] ) {

					playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );

				}

				if ( playerOnFloor ) {

					if ( keyStates[ 'Space' ] ) {

						playerVelocity.y = 35;

					}

				}

			}

			const loader = new GLTFLoader().setPath( '/gltf/' );
			loader.setMeshoptDecoder( MeshoptDecoder );
			const WORLD_FILE = 'mario_kart_8_-_sunshine_airport_compressed.glb';

			const loadWorld = () => {
				loader.load( WORLD_FILE, ( gltf ) => {

					scene.add( gltf.scene );

					worldOctree.fromGraphNode( gltf.scene );

					gltf.scene.traverse( child => {

						if ( child.isMesh ) {

							child.castShadow = true;
							child.receiveShadow = true;

							if ( child.material.map ) {

								child.material.map.anisotropy = 4;

							}

						}

					} );

					if ( ENABLE_DEBUG_GUI ) {
						const helper = new OctreeHelper( worldOctree );
						helper.visible = false;
						scene.add( helper );

						const gui = new GUI( { width: 200 } );
						gui.add( { debug: false }, 'debug' )
							.onChange( function ( value ) {

								helper.visible = value;

							} );
					}

					if ( loadingIndicator ) {
						loadingIndicator.textContent = 'World loaded';
						setTimeout( () => loadingIndicator.remove(), 250 );
					}

				}, ( event ) => {
					if ( ! loadingIndicator || ! event.total ) return;
					const percent = Math.min( 100, Math.round( ( event.loaded / event.total ) * 100 ) );
					loadingIndicator.textContent = `Loading world... ${percent}%`;
				} );
			};

			const scheduleWorldLoad = () => {
				if ( 'requestIdleCallback' in window ) {
					window.requestIdleCallback( loadWorld, { timeout: 2000 } );
				} else {
					setTimeout( loadWorld, 0 );
				}
			};

			scheduleWorldLoad();

			function teleportPlayerIfOob() {

				if ( camera.position.y <= - 25 ) {

					playerCollider.start.set( 0, PLAYER_CAPSULE_START_Y + PLAYER_SPAWN_OFFSET, 0 );
					playerCollider.end.set( 0, PLAYER_CAPSULE_END_Y + PLAYER_SPAWN_OFFSET, 0 );
					playerCollider.radius = PLAYER_CAPSULE_RADIUS;
					camera.position.copy( playerCollider.end );
					camera.rotation.set( 0, 0, 0 );

				}

			}

			function sendPlayerState( force = false ) {
				if ( ! socket.connected ) return;

				const now = performance.now();
				if ( ! force && now - lastPlayerUpdate < PLAYER_UPDATE_INTERVAL ) return;
				lastPlayerUpdate = now;

				tempNetworkVector.copy( playerCollider.start ).add( playerCollider.end ).multiplyScalar( 0.5 );

				socket.emit( 'playerUpdate', {
					position: {
						x: tempNetworkVector.x,
						y: tempNetworkVector.y,
						z: tempNetworkVector.z
					},
					rotation: {
						x: camera.rotation.x,
						y: camera.rotation.y,
						z: camera.rotation.z
					}
				} );
			}

			function ensureRemoteEntry( id ) {
				let entry = remotePlayers.get( id );
				if ( ! entry ) {
					entry = {
						group: null,
						body: null,
						head: null,
						label: null,
						username: '',
						color: DEFAULT_PLAYER_COLOR,
						lastCenter: null,
						lastRotation: 0
					};
					remotePlayers.set( id, entry );
				}
				return entry;
			}

			function createOrUpdateRemotePlayer( id, position = {}, rotation = {}, username = null, color = null ) {
				const entry = applyPlayerProfile( id, username, color );

				const hasValidPosition = position && Number.isFinite( position.x ) && Number.isFinite( position.y ) && Number.isFinite( position.z );
				if ( hasValidPosition ) {
					entry.lastCenter = { x: position.x, y: position.y, z: position.z };
				}

				if ( rotation && Number.isFinite( rotation.y ) ) {
					entry.lastRotation = rotation.y;
				}

				if ( ! entry.group ) {
					buildRemotePlayerAssets( entry );
					scene.add( entry.group );
				}

				applyRemoteTransform( entry );

				return entry;
			}

			function removeRemotePlayer( id ) {
				const entry = remotePlayers.get( id );
				if ( ! entry ) return;

				if ( entry.group ) {
					scene.remove( entry.group );
				}
				if ( entry.body?.material ) {
					entry.body.material.dispose();
				}
				if ( entry.head?.material ) {
					entry.head.material.dispose();
				}
				if ( entry.label?.material ) {
					if ( entry.label.material.map ) {
						entry.label.material.map.dispose();
					}
					entry.label.material.dispose();
				}

				remotePlayers.delete( id );
			}

			function buildNameTexture( text = 'Player', color = DEFAULT_PLAYER_COLOR ) {
				const canvas = document.createElement( 'canvas' );
				canvas.width = 256;
				canvas.height = 96;
				const ctx = canvas.getContext( '2d' );
				ctx.clearRect( 0, 0, canvas.width, canvas.height );

				const radius = 28;
				ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
				ctx.beginPath();
				ctx.moveTo( radius, 0 );
				ctx.lineTo( canvas.width - radius, 0 );
				ctx.quadraticCurveTo( canvas.width, 0, canvas.width, radius );
				ctx.lineTo( canvas.width, canvas.height - radius );
				ctx.quadraticCurveTo( canvas.width, canvas.height, canvas.width - radius, canvas.height );
				ctx.lineTo( radius, canvas.height );
				ctx.quadraticCurveTo( 0, canvas.height, 0, canvas.height - radius );
				ctx.lineTo( 0, radius );
				ctx.quadraticCurveTo( 0, 0, radius, 0 );
				ctx.closePath();
				ctx.fill();
				ctx.lineWidth = 2;
				ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
				ctx.stroke();

				ctx.font = '600 36px "Segoe UI", "Helvetica Neue", Arial, sans-serif';
				ctx.fillStyle = color || '#ffffff';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText( text, canvas.width / 2, canvas.height / 2 );

				const texture = new THREE.CanvasTexture( canvas );
				texture.anisotropy = 4;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				return texture;
			}

			function createNameLabelSprite( username, color ) {
				const texture = buildNameTexture( username, color );
				const material = new THREE.SpriteMaterial( { map: texture, transparent: true } );
				const sprite = new THREE.Sprite( material );
				sprite.scale.set( PLAYER_LABEL_SCALE_X, PLAYER_LABEL_SCALE_Y, 1 );
				sprite.position.set( 0, PLAYER_LABEL_OFFSET, 0 );
				return sprite;
			}

			function updateNameLabel( sprite, username, color ) {
				if ( ! sprite || ! sprite.material ) return;
				const oldTexture = sprite.material.map;
				const texture = buildNameTexture( username, color );
				sprite.material.map = texture;
				sprite.material.needsUpdate = true;
				if ( oldTexture ) {
					oldTexture.dispose();
				}
			}

			function setEntryColor( entry, color ) {
				entry.color = color || DEFAULT_PLAYER_COLOR;
				if ( entry.body ) {
					entry.body.material.color.set( entry.color );
				}
				if ( entry.head ) {
					const headTint = new THREE.Color( entry.color ).lerp( new THREE.Color( 0xffffff ), 0.6 );
					entry.head.material.color.set( headTint );
				}
				if ( entry.label ) {
					entry.label.scale.set( PLAYER_LABEL_SCALE_X, PLAYER_LABEL_SCALE_Y, 1 );
					entry.label.position.y = PLAYER_LABEL_OFFSET;
					updateNameLabel( entry.label, entry.username || 'Player', entry.color );
				}
			}

			function applyPlayerProfile( id, username, color ) {
				const entry = ensureRemoteEntry( id );
				if ( typeof username === 'string' && username.trim() ) {
					entry.username = username.trim();
					if ( entry.label ) {
						entry.label.scale.set( PLAYER_LABEL_SCALE_X, PLAYER_LABEL_SCALE_Y, 1 );
						entry.label.position.y = PLAYER_LABEL_OFFSET;
						updateNameLabel( entry.label, entry.username, entry.color );
					}
				}

				if ( typeof color === 'string' && color ) {
					setEntryColor( entry, color );
				}

				if ( entry.group && ! entry.label ) {
					entry.label = createNameLabelSprite( entry.username || 'Player', entry.color || DEFAULT_PLAYER_COLOR );
					entry.label.position.y = PLAYER_LABEL_OFFSET;
					entry.group.add( entry.label );
				}

				return entry;
			}

			function buildRemotePlayerAssets( entry ) {
				const group = new THREE.Group();
				group.scale.setScalar( PLAYER_SCALE );

				if ( entry.lastCenter ) {
					group.position.set( entry.lastCenter.x, entry.lastCenter.y, entry.lastCenter.z );
				}
				if ( typeof entry.lastRotation === 'number' ) {
					group.rotation.set( 0, entry.lastRotation, 0 );
				}

				const bodyMaterial = new THREE.MeshStandardMaterial( { color: entry.color || DEFAULT_PLAYER_COLOR } );
				const body = new THREE.Mesh( remoteBodyGeometry, bodyMaterial );
				body.castShadow = true;
				body.receiveShadow = true;
				group.add( body );

				const headColor = new THREE.Color( entry.color || DEFAULT_PLAYER_COLOR ).lerp( new THREE.Color( 0xffffff ), 0.6 );
				const head = new THREE.Mesh( remoteHeadGeometry, new THREE.MeshStandardMaterial( { color: headColor } ) );
				head.position.y = PLAYER_HEAD_OFFSET;
				head.castShadow = true;
				head.receiveShadow = true;
				group.add( head );

				const label = createNameLabelSprite( entry.username || 'Player', entry.color || DEFAULT_PLAYER_COLOR );
				label.position.y = PLAYER_LABEL_OFFSET;
				group.add( label );

				entry.group = group;
				entry.body = body;
				entry.head = head;
				entry.label = label;

				applyRemoteTransform( entry );
			}

			function applyRemoteTransform( entry ) {
				if ( ! entry.group || ! entry.lastCenter ) return;
				const desiredHeadCenter = entry.lastCenter.y + PLAYER_CENTER_TO_HEAD;
				const groupY = desiredHeadCenter - PLAYER_HEAD_WORLD_OFFSET;
				entry.group.position.set( entry.lastCenter.x, groupY, entry.lastCenter.z );
				if ( typeof entry.lastRotation === 'number' ) {
					entry.group.rotation.y = entry.lastRotation;
				}
			}

			function animate() {

				const deltaTime = Math.min( 0.05, clock.getDelta() ) / STEPS_PER_FRAME;

				// we look for collisions in substeps to mitigate the risk of
				// an object traversing another too quickly for detection.

				for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {

					controls( deltaTime );

					updatePlayer( deltaTime );

					updateSpheres( deltaTime );

					teleportPlayerIfOob();

				}

				sendPlayerState();

				remotePlayers.forEach( ( entry ) => {
					if ( entry.label ) {
						entry.label.quaternion.copy( camera.quaternion );
					}
				} );

				renderer.render( scene, camera );

				if ( stats ) {
					stats.update();
				}

			}

		</script>
	</body>
</html>
